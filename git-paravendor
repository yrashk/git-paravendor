#! /usr/bin/env bash

# defer implementation by Patrick Hemmer @phemmer
# https://gist.github.com/phemmer/e943dce38eaa948f1893d9392741970f
function _run_deferred() {
  local _depth="$BASHPID.${#FUNCNAME[@]}"
  [[ "$_depth" != "$_deferred_depth" ]] && return
  local opt=$-
  set +e
  for (( i=${#_deferred[@]} - 1; i >= 0; i-- )); do
    eval "${_deferred[i]}"
  done
  [[ "$opt" == *e* ]] && set -e
}
function _defer() {
  _deferred_depth="$BASHPID.${#FUNCNAME[@]}"
  _deferred+=( "$(printf '%q ' "$@")" )
}
# This has to be an alias so that the `trap ... RETURN` runs appropriately.
shopt -s expand_aliases
alias defer='declare -a _deferred; declare _deferred_depth; trap _run_deferred EXIT RETURN; _defer'
#


working_directory_clean () {
  if output=$(git status --porcelain) && [ -z "$output" ]; then
    return 0
  else
    return 1
  fi
}

check_if_initialized () {
  git show-ref --quiet --verify refs/heads/paravendor && return 0 
  branch=$(git rev-parse --abbrev-ref HEAD)
  remote=$(git config branch."$branch".remote)
  if [[ -z "$remote" ]]; then
    remote=origin
  fi;
  if [[ -z "$(git ls-remote "$remote" refs/heads/paravendor)" ]]; then
    return 1
  else
    git fetch --no-tags --quiet "$remote" || return 1
    git show-ref --quiet --verify "refs/remotes/$remote/paravendor" || return 1
    git branch --quiet paravendor "$remote/paravendor" || return 1
    git branch --quiet --set-upstream-to="$remote/paravendor" paravendor || return 1
  fi
}

sync() {
  git fetch "$1" --prune --no-tags
  echo -n "Fetching & adding refs: "
  refs=""
  while read -r commit_hash ref_name; do
    [[ "$(git config -f "$top_level/config" --get ref."$1#$ref_name".commit)" == "$commit_hash" ]] && { echo -n "="; continue; }
    git rev-list --quiet "$commit_hash" 2>/dev/null || { echo -n "_" ; continue; }
    git config -f "$top_level/config" --add ref."$1#$ref_name".commit "$commit_hash"
    git config -f "$top_level/config" --add ref."$1".refs "$ref_name"
    if [[ "$refs" == *"$commit_hash"* ]]; then
      true
    else 
      refs="$refs -p $commit_hash"
    fi
    echo -n "."
  done <<< "$(git ls-remote --heads --tags "$1")"
  echo
  git add "$top_level/config" || { echo "can't add config"; return 1;}
  git commit --quiet -m "git paravendor: sync remote: $1" || { echo "can't commit config" ; return 1; }
  tree=$(git rev-parse --short 'HEAD^{tree}')
  merge=$(git commit-tree "$tree" $refs -p "$(git rev-parse --short HEAD)" -m "git paravendor: ref sync for $1")
  if [ $? -ne 0 ]; then
    echo "can't commit merge";
    return 1
  fi
  git update-ref refs/heads/paravendor "$merge" || { echo "can't update ref for paravendor"; return 1; }
}


case "$1" in
  init)
    working_directory_clean || { echo "git working directory is not clean, aborting"; exit 1; }
    top_level=$(git rev-parse --show-toplevel)
    git show-ref  --quiet --verify refs/heads/paravendor && { echo "'paravendor' branch already exists, aborting"; exit 1;}
    tmpdir=$(mktemp -d)
    git init --quiet "$tmpdir"
    cd "$tmpdir"
    git config -f "config" --add paravendor.version 1 || { echo "can't init config" ; exit 1; }
    git add "config" || { echo "can't add config"; exit 1; }
    git commit --quiet -m "git paravendor init" || { echo "can't commit config"; exit 1; }
    git push "$top_level" master:paravendor --quiet --force || { echo "can't push paravendor branch"; exit 1; }
    rm -rf "$tmpdir"
    ;;
  add)
    check_if_initialized || { echo "not initialized, run 'git paravendor init' first" ; exit 1; }
    working_directory_clean || { echo "git working directory is not clean, aborting"; exit 1; }
    top_level=$(git rev-parse --show-toplevel)
    echo "Adding $2"
    git checkout --quiet paravendor
    defer git switch --quiet -
    git config -f "$top_level/config" --get-urlmatch remote.added "$2" >/dev/null && { echo "$2 has been already added, aborting"; exit 1; }
    git config -f "$top_level/config" --add remote."$2".added true || { echo "can't modify config"; exit 1; }
    git config -f "$top_level/config" --add paravendor.remote "$2" || { echo "can't modify config"; exit 1; }
    sync "$2" || exit 1
    ;;
  sync)
    check_if_initialized || { echo "not initialized, run 'git paravendor init' first" ; exit 1; }
    working_directory_clean || { echo "git working directory is not clean, aborting"; exit 1; }
    if [ -z "$2" ]; then
      while read -r remote; do
        git paravendor sync "$remote"
      done <<< "$(git paravendor list)"
    else
        echo "Syncing $2"
        top_level=$(git rev-parse --show-toplevel)
        git checkout --quiet paravendor || { echo "can't check out paravendor branch"; exit 1; }
        defer git switch --quiet -
        sync "$2" || exit 1
    fi
    ;;
  list)
    check_if_initialized || { echo "not initialized, run 'git paravendor init' first" ; exit 1; }
    git config --blob "$(git ls-tree --object-only paravendor config)" --get-all paravendor.remote
    ;;
  show-refs)
    check_if_initialized || { echo "not initialized, run 'git paravendor init' first" ; exit 1; }
    git config --blob "$(git ls-tree --object-only paravendor config)" --get-all ref."$2".refs
    ;;
  show-ref)
    check_if_initialized || { echo "not initialized, run 'git paravendor init' first" ; exit 1; }
    git config --blob "$(git ls-tree --object-only paravendor config)" --get ref."$2#refs/heads/$3".commit ||
    git config --blob "$(git ls-tree --object-only paravendor config)" --get ref."$2#refs/tags/$3^{}".commit ||
    git config --blob "$(git ls-tree --object-only paravendor config)" --get ref."$2#refs/tags/$3".commit ||
    git config --blob "$(git ls-tree --object-only paravendor config)" --get ref."$2#$3".commit 
    ;;
  *)
    echo "Unknown command"
    exit 1 
    ;;
esac
